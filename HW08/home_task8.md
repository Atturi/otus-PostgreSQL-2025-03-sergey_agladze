
## Домашнее задание #8

### Среда выполнения

Операционная система: **Linux Fedora 41**
Способ развёртывания БД: **Docker**
Версия **PostgreSQL**: 15.12

### Задания

> Настройте сервер так, чтобы в журнал сообщений сбрасывалась информация о блокировках, удерживаемых более 200 миллисекунд. Воспроизведите ситуацию, при которой в журнале появятся такие сообщения.

**Настройка сервера**:
- alter system set log_lock_waits = on;
- alter system set log_min_message = 'info';
- alter system set deadlock_timeout = '200ms';
- alter system set lock_timeout = '1s';
- alter system set logging_collector = on;

**Воспроизведение блокировки**:
- create table lock_test(id serial, name test);
- insert into lock_test(name) values('name1');
- (Сессия 1) begin; update lock_test set name = 'NAME' where id = 1;
- (Сессия 2) begin; update lock_test set name = 'NAME' where id = 1;

**Сообщения в журнале**:
2025-05-15 17:43:41.524 GMT [50] LOG:  process 50 still waiting for ShareLock on transaction 3188777 after 200.165 ms
2025-05-15 17:43:41.524 GMT [50] DETAIL:  Process holding the lock: 42. Wait queue: 50.
2025-05-15 17:43:41.524 GMT [50] CONTEXT:  while updating tuple (0,1) in relation "lock_test"
2025-05-15 17:43:41.524 GMT [50] STATEMENT:  update lock_test set name = 'NAME' where id = 1;

> Смоделируйте ситуацию обновления одной и той же строки тремя командами UPDATE в разных сеансах. Изучите возникшие блокировки в представлении pg_locks и убедитесь, что все они понятны. Пришлите список блокировок и объясните, что значит каждая.

Скриншот со списком блокировок приложен в отдельном файле.
1. Блокировка на таблицу lock_test для обновления строки.
2. Блокировка транзакцией своего уникального идентификатора.
3. Блокировка транзакцией уникального идентификатора. mode = ExclusiveLock означает, что транзакция является владельцем указанного идентификатора.
4. Транзакций ожидает блокировку на строку, которая захвачена первой транзакцией. У первой транзакции подобная блокировка не видна, потому что она её не ждёт.
5. Транзакция ждёт транзакцию с указанным идентификатором._te
6. Транзакция устанавливает блокировку на таблицу lock_test для обновления строки.
7. Транзакция удерживает блокировку на свой уникальный виртуальный идентификатор.
8. Транзакция удерживает блокировку на свой уникальный идентификатор.
9. Транзакция удерживает блокировку на свой уникальный индетификатор.
10. Транзакция удерживает блокировку на таблицу lock_test для обновления строки.
11. Транзакция удерживает блокировку на обновляемую строку. Блокировка не предоставлена, потому что ожидается завершение другой транзакции, владеющей этой блокировкой.
12. Транзакция удерживает блокировку на свой уникальный идентификатор.

> Воспроизведите взаимоблокировку трёх транзакций. Можно ли разобраться в ситуации постфактум, изучая журнал сообщений?

Сессия 1: update lock_test set name = 'NAME1' where id = 1;
Сессия 2: update lock_test set name = 'NAME2' where id = 2;
Сессия 3: update lock_test set name = 'NAME3' where id = 3;
Сессия 1: update lock_test set name = 'test3' where id = 3;
Сессия 3: update lock_test set name = 'test2' where id = 2;
Сессия 2: update lock_test set name = 'test1' where id = 1;

Разобраться в ситуации по журналу можно: там перечислены все операции обновления, захватывающие блокировку, а также связи между процессами.

> Могут ли две транзакции, выполняющие единственную команду UPDATE одной и тоже таблицы, заблокировать друг друга?

Да. Для этого достаточно, чтобы они обновили одинаковые строки в разному подряке.


## Домашнее задание #12

### Среда выполнения

Операционная система: **Linux Fedora 42**

Способ развёртвывания **PostgreSQL**: **Docker**

Версия **PostgreSQL**: 17.0

### Выполнение

Триггер приложен в файле *t_sales_report_update*. Триггерная функция приложена в файле *f_sales_report_update*.

> Insert

При добавлении записи в  *sales* будет добавляться запись в *good_sum_mart*. В случае, если запись с данным товаром уже есть в *good_sum_mart*, происходит *update* вместо *insert*. Данный алгоритм реализуется через конструкциию *on conflict*, для использования которой необходимо в таблицу *good_sum_mart* добавить уникальный ключ(файл *add_unique_key*). 

> Update

Количество товара в продаже должно быть больше 0.

При обновлении записи может поменяться поле *good_id*. В этом случае нужно обновить 2 товара в отчёте: старый и новый. При этом старый товар может полностью удалиться, если обновляемая запись - единственная запись с этим товаром, а новый товар может ещё отсутствовать в отчёте. 

> Delete

При удалении записи общая сумма в отчёте уменьшается на сумму удаляемой продажи. Если удаляется последняя продажа товара(её сумма равна общей сумме по товару в отчёте), товар удаляется из отчёта.

> Задание со звёздочкой

Если отчёт формируется исходным запросом, при обновлении цены товара мы будем получать некорректные данные о старых продажах. Однако, в текущей архитектуре таблиц проблема изменения цены не устраняется при переходе на триггер: при обновлении или удалении данных нам приходится обращаться к текущей цене. Это даст некорректный результат при обновлении/удалении продаж, совершённых до обновления цены. Для полного устранения проблемы нужна историчность цен.
